---
title: "R Notebook"
output: github_document
---
TUTORIEL DADA2


https://benjjneb.github.io/dada2/tutorial.html#:~:text=Here%20we%20walk%20through%20version%201.16%20of%20the%20DADA2%20pipeline
library()

1)GETTING READY

Ici, j'appelle le package dada2
Je met mon dossier "MiSeq_SOP" dans une variable "path"
Ce qui me permet de lister les fichier contenu dans "path" et donc dans "miSeq_SOP"
```{r}
library(dada2); packageVersion("dada2")
path<-"/home/rstudio/DADA2_tutorial_ADM/MiSeq_SOP"
list.files(path)
```
Je stock dans les variables "fnFs" et "fnRs" respectivement l'ensemble des fichiers contenants "_R1_" et "_R2_" dans leur nom, c'est à dire les sequences forward et reverse.

full.names=TRUE --> tout le chemin et pas que le nom du fichier
pattern="xxxx"-->les fichiers dont le nom contient "xxxx"
path-->on va chercher les fichiers dans la variable "path" (qui contient les fichiers du dossier MiSeq_SOP)
list.files-->lister les fichiers
sort-->par ordre alphabetique
```{r}
fnFs<-sort(list.files(path, pattern="_R1_", full.names=TRUE))
fnRs<-sort(list.files(path, pattern="_R2_", full.names=TRUE))
fnRs
fnFs
```
strsplit-->separe un nom
basename(file)-->renvoie au nom du fichier et non pas du chemin
split"_"--> sépare le fichier en un vecteur contenant toutes les portions de noms entre les "_"

sapply()-->applique une fonction à chaque élément de la liste
FUN='['--> applique la fonction à un vecteur
1--> choisis le premier élément du vecteur

```{r}
sample.names_F<-sapply(strsplit(basename(fnFs),split="_"), FUN='[', 1)
sample.names_R<-sapply(strsplit(basename(fnRs),split="_"), FUN='[', 1)
sample.names_R
sample.names_F
```
2)INSPECT READ QUALITY PROFILES
plotQualityProfile-->fait apparaitre un graphe avec en y une heatmap de la fréquence de chaque quality score et en x la position de chaque nucléotide.

On remarque que le quality score moyen (en vert) diminue au fur et à mesure car la fidélité sequançage diminue dans le temps. De plus, les séquences reverse semblent perdre en qualité plus tôt que les séquences forward.

```{r}
plotQualityProfile(fnFs [c(1, 10, 20)])
plotQualityProfile(fnRs[c(3, 9, 18)])
```
3) FILTER AND TRIM
file.path()-->créer un chemin de fichier
path-->contient le dossier où se trouve les fichiers d'interet
"filtered"-->ajoute un dossier "filtered" à ce chemin
paste0()-->faire un collage entre le vecteur sample.names_F et le suffixe "_F_filt.fastq.gz"

```{r}
filtFs <- file.path(path, "filtered", paste0(sample.names_F, "_F_filt.fastq.gz"))
filtRs <- file.path(path, "filtered", paste0(sample.names_R, "_R_filt.fastq.gz"))
filtFs
filtRs
```
Ici, je viens stocker dans les fichiers filtFs et filtRs mes échantillons fnFs et fnRs une fois ceux-ci filtrés et tronqués par la fonction filterAndtrim() comme ceci :

trunclen=c(240,160)--> seq tronquées après 240 (forward) et 160 (reverse) nucleotides
maxN=0--> toute seq contenant au moins une base N (ambigue) sera éliminée.
maxEE=c(2,2)--> max expected errors quality score 2 (forward et reverse) (phred score)-->https://en.wikipedia.org/wiki/Phred_quality_score
truncQ=2--> seq tronquée dès que Phred score est de 2
rm.phix=TRUE-->les seq du phage PhiX sont supprimées, il est utilisé comme controle dans le sequencage (c'est une verification).
compress=TRUE--> fichiers de sortie seront compressés en format gzip (fichier .gz)
multithread=TRUE-->utilise plusieurs coeurs du processeur pour executer plus vite

```{r}
out <- filterAndTrim(fnFs, filtFs, fnRs, filtRs, truncLen=c(240,160),
              maxN=0, maxEE=c(2,2), truncQ=2, rm.phix=TRUE,
              compress=TRUE, multithread=TRUE)
head(out)
```
4) LEARN THE ERRORS RATES

learnErrors()-->modélise les probabilités d'erreurs.
plotErrors-->afficher les taux d'erreurs observé à partir des données réelles (POINTS NOIRS)
             le taux d'erreurs estimé par learnErrors()(LIGNE NOIRE)
             nominalQ=TRUE permet d'afficher le taux d'erreurs nominal de la plateforme dada2 sans apprentissage de mes données (LIGNE ROUGE)
             
```{r}
errF <- learnErrors(filtFs, multithread=TRUE)
errR <- learnErrors(filtRs, multithread=TRUE)
plotErrors(errF, nominalQ=TRUE)
plotErrors(errR, nominalQ=TRUE)
```
5) SAMPLE INFERENCE

Ici, j'applique l'algo dada à mes échantillons de bonnes qualités filtFs, avec err=errF indiquant que mon modèle d'erreur est errF.
L'algorithme dada permet de differencier les differences de sequences dûent à des variations d'origine biologique ou à celles issue d'erreures de séquençage. (cf CM APO).
```{r}
dadaFs <- dada(filtFs, err=errF, multithread=TRUE)
dadaRs <- dada(filtRs, err=errR, multithread=TRUE)
dadaFs[[1]]
```
```{r}
?setDadaOpt
```
```{r}
help("dada-class")
```









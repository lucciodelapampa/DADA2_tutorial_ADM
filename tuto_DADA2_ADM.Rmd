---
title: "R Notebook"
output: github_document
---
TUTORIEL DADA2


https://benjjneb.github.io/dada2/tutorial.html#:~:text=Here%20we%20walk%20through%20version%201.16%20of%20the%20DADA2%20pipeline
library()

1)GETTING READY

Ici, j'appelle le package dada2
Je met mon dossier "MiSeq_SOP" dans une variable "path"
Ce qui me permet de lister les fichier contenu dans "path" et donc dans "miSeq_SOP"
```{r}
library(dada2); packageVersion("dada2")
path<-"/home/rstudio/DADA2_tutorial_ADM/MiSeq_SOP"
list.files(path)
```
Je stock dans les variables "fnFs" et "fnRs" respectivement l'ensemble des fichiers contenants "_R1_" et "_R2_" dans leur nom, c'est à dire les sequences forward et reverse.

full.names=TRUE --> tout le chemin et pas que le nom du fichier
pattern="xxxx"-->les fichiers dont le nom contient "xxxx"
path-->on va chercher les fichiers dans la variable "path" (qui contient les fichiers du dossier MiSeq_SOP)
list.files-->lister les fichiers
sort-->par ordre alphabetique
```{r}
fnFs<-sort(list.files(path, pattern="_R1_", full.names=TRUE))
fnRs<-sort(list.files(path, pattern="_R2_", full.names=TRUE))
fnRs
fnFs
```
strsplit-->separe un nom
basename(file)-->renvoie au nom du fichier et non pas du chemin
split"_"--> sépare le fichier en un vecteur contenant toutes les portions de noms entre les "_"

sapply()-->applique une fonction à chaque élément de la liste
FUN='['--> applique la fonction à un vecteur
1--> choisis le premier élément du vecteur

```{r}
sample.names<-sapply(strsplit(basename(fnFs),split="_"), FUN='[', 1)
sample.names
```
2)INSPECT READ QUALITY PROFILES

plotQualityProfile-->fait apparaitre un graphe avec en y une heatmap de la fréquence de chaque quality score et en x la position de chaque nucléotide.

On remarque que le quality score moyen (en vert) diminue au fur et à mesure car la fidélité sequançage diminue dans le temps. De plus, les séquences reverse semblent perdre en qualité plus tôt que les séquences forward.

```{r}
plotQualityProfile(fnFs [c(1, 10, 20)])
plotQualityProfile(fnRs[c(3, 9, 18)])
```
3) FILTER AND TRIM

file.path()-->créer un chemin de fichier
path-->contient le dossier où se trouve les fichiers d'interet
"filtered"-->ajoute un dossier "filtered" à ce chemin
paste0()-->faire un collage entre le vecteur sample.names_F et le suffixe "_F_filt.fastq.gz"

```{r}
filtFs <- file.path(path, "filtered", paste0(sample.names, "_F_filt.fastq.gz"))
filtRs <- file.path(path, "filtered", paste0(sample.names, "_R_filt.fastq.gz"))
filtFs
filtRs
```
Ici, je viens stocker dans les fichiers filtFs et filtRs mes échantillons fnFs et fnRs une fois ceux-ci filtrés et tronqués (et filtré) par la fonction filterAndtrim() comme ceci :

trunclen=c(240,160)--> seq tronquées après 240 (forward) et 160 (reverse) nucleotides
maxN=0--> toute seq contenant au moins une base N (ambigue) sera éliminée.
maxEE=c(2,2)--> max expected errors quality score 2 (forward et reverse) (phred score)-->https://en.wikipedia.org/wiki/Phred_quality_score
truncQ=2--> seq tronquée dès que Phred score est de 2
rm.phix=TRUE-->les seq du phage PhiX sont supprimées, il est utilisé comme controle dans le sequencage (c'est une verification).
compress=TRUE--> fichiers de sortie seront compressés en format gzip (fichier .gz)
multithread=TRUE-->utilise plusieurs coeurs du processeur pour executer plus vite

```{r}
out <- filterAndTrim(fnFs, filtFs, fnRs, filtRs, truncLen=c(240,160),
              maxN=0, maxEE=c(2,2), truncQ=2, rm.phix=TRUE,
              compress=TRUE, multithread=TRUE)
head(out)
```
4) LEARN THE ERRORS RATES

learnErrors()-->modélise les probabilités d'erreurs.
plotErrors-->afficher les taux d'erreurs observé à partir des données réelles (POINTS NOIRS)
             le taux d'erreurs estimé par learnErrors()(LIGNE NOIRE)
             nominalQ=TRUE permet d'afficher le taux d'erreurs nominal de la plateforme dada2 sans apprentissage de mes données (LIGNE ROUGE)
             
```{r}
errF <- learnErrors(filtFs, multithread=TRUE)
errR <- learnErrors(filtRs, multithread=TRUE)
plotErrors(errF, nominalQ=TRUE)
plotErrors(errR, nominalQ=TRUE)
```
5) SAMPLE INFERENCE

Ici, j'applique l'algo dada à mes échantillons de bonnes qualités filtFs, avec err=errF indiquant que mon modèle d'erreur est errF.
L'algorithme dada permet de differencier les differences de sequences dûent à des variations d'origine biologique ou à celles issue d'erreures de séquençage. (cf CM APO).
```{r}
dadaFs <- dada(filtFs, err=errF, multithread=TRUE)
dadaRs <- dada(filtRs, err=errR, multithread=TRUE)
dadaFs[[1]]
```
```{r}
?setDadaOpt
```
```{r}
help("dada-class")
```
6) MERGE PAIRED READS

mergePairs()--> permet la fusion des forwards et reverses après le débruitage.
il faut lui préciser dadaFs puis filtFs pour lui dire le chemin d'accès.

verbose=TRUE

Progrès des fusions : Le nombre de paires de séquences en cours de traitement est affiché pendant que DADA2 procède à la fusion. Cela permet de suivre la progression du processus.

Résumé des fusions : Des statistiques sur le nombre total de lectures appariées, ainsi que des détails sur les fusions réussies ou échouées, sont rapportées.

Informations sur les erreurs : Si des paires de séquences ne parviennent pas à fusionner, par exemple en raison d'un chevauchement insuffisant ou d'un trop grand nombre de mésappariements, ces informations seront également affichées.
```{r}
mergers <- mergePairs(dadaFs, filtFs, dadaRs, filtRs, verbose=TRUE)
head(mergers[[1]])
```
7) CONSTRUCT SEQUENCE TABLE

makeSequenceTable()--> Elle prend les résultats de la fusion des lectures (comme dans mergers) et produit une matrice dans laquelle :
Chaque ligne correspond à un échantillon.
Chaque colonne correspond à une séquence unique (ASV) identifiée après fusion.
Les valeurs dans la matrice indiquent le nombre d'occurrences (abondance) de chaque séquence unique dans chaque échantillon.
```{r}
seqtab<-makeSequenceTable(mergers)
dim(seqtab)
```
getSequences(seqtab) :
Cette fonction extrait toutes les séquences uniques (les ASVs) de la table seqtab en tant que vecteur de chaînes de caractères. Chaque élément de ce vecteur correspond à une séquence unique détectée après débruitage et fusion des lectures.

nchar() :
Calcule la longueur de chaque séquence dans le vecteur, c'est-à-dire le nombre de nucléotides dans chaque séquence.

table() :
Crée une table de fréquence montrant combien de séquences ont une certaine longueur (nombre de nucléotides). Elle renvoie une table où :
Chaque valeur correspond au nombre de séquences ayant une longueur donnée.
Chaque nom de colonne correspond à une longueur spécifique.
```{r}
table(nchar(getSequences(seqtab)))
```
8) REMOVE CHIMERAS

removeBimeraDenovo() :
Identifie et retire les séquences chimériques dans la table de séquences. Les chimères se forment lorsqu'un fragment d'ADN est mal répliqué pendant la PCR, donnant une séquence hybride entre deux séquences existantes.

Arguments :

method="consensus" : La méthode "consensus" compare chaque séquence à d'autres séquences plus abondantes. Une séquence est considérée comme chimérique si elle peut être formée par la combinaison de deux séquences parentales.
verbose=TRUE : Affiche des informations supplémentaires sur le processus de suppression des chimères.
```{r}
seqtab.nochim <- removeBimeraDenovo(seqtab, method="consensus", multithread=TRUE, verbose=TRUE)
dim(seqtab.nochim)
```
Calcul de la proportion des séquences non chimériques par rapport au total des séquences
```{r}
sum(seqtab.nochim)/sum(seqtab)
```
9) TRACK READS THROUGH THE PIPELINE
Je definis une fonction getN avec function(x), x sera le paramètre d'entrée.
sun(getUniques(x))-->additionne toute les occurences des sequences uniques obtenues grâce à getUniques(x)
On compte donc le nombre de sequences uniques.

```{r}
getN <- function(x) sum(getUniques(x))
```
Création d'une matrice track qui contient une colonne pour chaque étape du pipeline, chaque ligne est un echantillon.

cbind()-->combine des objets par colonne, prend plusieurs vecteurs ou matrices et les met côte à côte pour créer une nouvelle matrice avec le même nombre de lignes.

sapply(dadaRs/dadaFs, getN)--> applique getN, calculant le nombre de séquences uniques pour chaque échantillon après débruitage des lectures inverses.

sapply(mergers, getN)--> applique la fonction getN pour calculer le nombre de séquences uniques après la fusion des lectures. Ce vecteur indique combien de séquences uniques sont restées après l'étape de fusion.

rowSums(seqtab.nochim)-->calcule la somme des séquences non chimériques pour chaque échantillon, donnant ainsi le nombre final de séquences de haute qualité.

rownames(track) <- sample.names  --> attribue les noms des lignes à la matrice track en utilisant les noms des échantillons


```{r}
track <- cbind(out, sapply(dadaFs, getN), sapply(dadaRs, getN), sapply(mergers, getN), rowSums(seqtab.nochim))
colnames(track) <- c("input", "filtered", "denoisedF", "denoisedR", "merged", "nonchim")
rownames(track) <- sample.names
head(track)
```
Une bonne portion des inputs ont passés les differentes étapes de filtration, ce qui veut dire que mes paramètres de tris ne sont pas trop strictes.

10) ASSIGN TAXONOMY


assignTaxonomy()-->attribue une classification taxonomique à seqtab.nochim en se basant sur une base de données de référence, ici SILVA 132
```{r}
taxa <- assignTaxonomy(seqtab.nochim, "/home/rstudio/tutoDada2/silva_nr_v132_train_set.fa.gz", multithread=TRUE)
```
addSpecies()-->ajoute des noms d'espèces à une table de taxonomie
```{r}
taxa <- addSpecies(taxa, "/home/rstudio/tutoDada2/silva_species_assignment_v132.fa.gz")
```
taxa.print <- taxa-->crée une copie de  taxa sous le nom taxa.print. Ainsi, les modifications apportées à taxa.print n'affecteront pas taxa.

rownames(taxa.print) <- NULL-->supprime les noms de ligne

```{r}
taxa.print <- taxa
rownames(taxa.print) <- NULL
head(taxa.print)
```
11) EVALUATE ACCURACY

Évaluation de la précision de DADA2 sur la communauté fictive

seqtab.nochim["Mock",]-->extrait les sequences associées à l'échantillon de reference Mock dans seqtab.nochim
, indique que je prend toutes les colonnes (toutes les séquences associées à cet échantillon).
```{r}
unqs.mock <- seqtab.nochim["Mock_F_filt.fastq.gz",]
```

Trie les séquences de l'échantillon "Mock" par ordre décroissant de leur abondance, après avoir filtré les séquences avec une abondance supérieure à zéro : 

unqs.mock[unqs.mock > 0]-->sélectionne uniquement les séquences dont l'abondance>0, c'est-à-dire, les séquences réellement observées dans l'échantillon "Mock".

sort(..., decreasing = TRUE)-->sort() trie les valeurs dans l'ordre croissant. En ajoutant decreasing = TRUE, les séquences sont triées par ordre décroissant, de l'abondance la plus élevée à la plus faible.
```{r}
unqs.mock <- sort(unqs.mock[unqs.mock>0], decreasing=TRUE)
```
cat()-->concaténer et afficher des éléments. Ici, elle affiche un message comprenant du texte et une valeur calculée.

length(unqs.mock-->renvoie le nombre d'éléments dans l'objet unqs.mock. Cela correspond au nombre de séquences uniques présentes dans l'échantillon "Mock", après avoir appliqué le tri et la suppression des séquences avec une abondance de zéro.

```{r}
cat("DADA2 inferred", length(unqs.mock), "sample sequences present in the Mock community.\n")

```
Extrait les séquences de référence à partir d'un fichier FASTA pour l'échantillon "Mock" et les stocke dans l'objet mock.ref

```{r}
mock.ref <- getSequences(file.path(path, "HMP_MOCK.v35.fasta"))
```
Comparer les séquences inférées dans l'échantillon "Mock" avec les séquences de référence et compter combien d'entre elles correspondent à celles présentes dans le fichier de référence (mock.ref)
```{r}
match.ref <- sum(sapply(names(unqs.mock), function(x) any(grepl(x, mock.ref))))
```
```{r}
cat("Of those,", match.ref, "were exact matches to the expected reference sequences.\n")
```
On a bien 20/20 en correspondance avec l'echantillon de reference mock, ce qui signifie qu'aucune erreure majeur dans le sequencage ni dans le pipeline dada2 n'est a declaré.
















